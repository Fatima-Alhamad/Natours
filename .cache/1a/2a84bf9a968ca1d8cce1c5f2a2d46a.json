{"id":"../../node_modules/stripe/cjs/net/NodeHttpClient.js","dependencies":[{"name":"C:\\Users\\Admin\\OneDrive\\Desktop\\NodeYT\\4-natours\\start\\starter\\package.json","includedInParent":true,"mtime":1728203676019},{"name":"C:\\Users\\Admin\\OneDrive\\Desktop\\NodeYT\\4-natours\\start\\starter\\node_modules\\stripe\\cjs\\package.json","includedInParent":true,"mtime":1728153801429},{"name":"http","loc":{"line":4,"column":22,"index":165},"parent":"C:\\Users\\Admin\\OneDrive\\Desktop\\NodeYT\\4-natours\\start\\starter\\node_modules\\stripe\\cjs\\net\\NodeHttpClient.js","resolved":"C:\\Users\\Admin\\OneDrive\\Desktop\\NodeYT\\4-natours\\start\\starter\\node_modules\\stream-http\\index.js"},{"name":"https","loc":{"line":5,"column":23,"index":197},"parent":"C:\\Users\\Admin\\OneDrive\\Desktop\\NodeYT\\4-natours\\start\\starter\\node_modules\\stripe\\cjs\\net\\NodeHttpClient.js","resolved":"C:\\Users\\Admin\\OneDrive\\Desktop\\NodeYT\\4-natours\\start\\starter\\node_modules\\https-browserify\\index.js"},{"name":"./HttpClient.js","loc":{"line":6,"column":32,"index":239},"parent":"C:\\Users\\Admin\\OneDrive\\Desktop\\NodeYT\\4-natours\\start\\starter\\node_modules\\stripe\\cjs\\net\\NodeHttpClient.js","resolved":"C:\\Users\\Admin\\OneDrive\\Desktop\\NodeYT\\4-natours\\start\\starter\\node_modules\\stripe\\cjs\\net\\HttpClient.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NodeHttpClientResponse = exports.NodeHttpClient = void 0;\nconst http_ = require(\"http\");\nconst https_ = require(\"https\");\nconst HttpClient_js_1 = require(\"./HttpClient.js\");\n// `import * as http_ from 'http'` creates a \"Module Namespace Exotic Object\"\n// which is immune to monkey-patching, whereas http_.default (in an ES Module context)\n// will resolve to the same thing as require('http'), which is\n// monkey-patchable. We care about this because users in their test\n// suites might be using a library like \"nock\" which relies on the ability\n// to monkey-patch and intercept calls to http.request.\nconst http = http_.default || http_;\nconst https = https_.default || https_;\nconst defaultHttpAgent = new http.Agent({ keepAlive: true });\nconst defaultHttpsAgent = new https.Agent({ keepAlive: true });\n/**\n * HTTP client which uses the Node `http` and `https` packages to issue\n * requests.`\n */\nclass NodeHttpClient extends HttpClient_js_1.HttpClient {\n    constructor(agent) {\n        super();\n        this._agent = agent;\n    }\n    /** @override. */\n    getClientName() {\n        return 'node';\n    }\n    makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n        const isInsecureConnection = protocol === 'http';\n        let agent = this._agent;\n        if (!agent) {\n            agent = isInsecureConnection ? defaultHttpAgent : defaultHttpsAgent;\n        }\n        const requestPromise = new Promise((resolve, reject) => {\n            const req = (isInsecureConnection ? http : https).request({\n                host: host,\n                port: port,\n                path,\n                method,\n                agent,\n                headers,\n                ciphers: 'DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:!MD5',\n            });\n            req.setTimeout(timeout, () => {\n                req.destroy(HttpClient_js_1.HttpClient.makeTimeoutError());\n            });\n            req.on('response', (res) => {\n                resolve(new NodeHttpClientResponse(res));\n            });\n            req.on('error', (error) => {\n                reject(error);\n            });\n            req.once('socket', (socket) => {\n                if (socket.connecting) {\n                    socket.once(isInsecureConnection ? 'connect' : 'secureConnect', () => {\n                        // Send payload; we're safe:\n                        req.write(requestData);\n                        req.end();\n                    });\n                }\n                else {\n                    // we're already connected\n                    req.write(requestData);\n                    req.end();\n                }\n            });\n        });\n        return requestPromise;\n    }\n}\nexports.NodeHttpClient = NodeHttpClient;\nclass NodeHttpClientResponse extends HttpClient_js_1.HttpClientResponse {\n    constructor(res) {\n        // @ts-ignore\n        super(res.statusCode, res.headers || {});\n        this._res = res;\n    }\n    getRawResponse() {\n        return this._res;\n    }\n    toStream(streamCompleteCallback) {\n        // The raw response is itself the stream, so we just return that. To be\n        // backwards compatible, we should invoke the streamCompleteCallback only\n        // once the stream has been fully consumed.\n        this._res.once('end', () => streamCompleteCallback());\n        return this._res;\n    }\n    toJSON() {\n        return new Promise((resolve, reject) => {\n            let response = '';\n            this._res.setEncoding('utf8');\n            this._res.on('data', (chunk) => {\n                response += chunk;\n            });\n            this._res.once('end', () => {\n                try {\n                    resolve(JSON.parse(response));\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n}\nexports.NodeHttpClientResponse = NodeHttpClientResponse;\n"},"sourceMaps":null,"error":null,"hash":"df58a9bc5e693c98b4299b73002f0f6f","cacheData":{"env":{}}}